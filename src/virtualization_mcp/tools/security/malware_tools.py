"""
Malware Analysis Tools for virtualization-mcp.

This module provides tools for analyzing files and processes for potential malware.
"""

import asyncio
import hashlib
import logging
import shutil
from datetime import datetime, timedelta
from enum import Enum
from pathlib import Path
from typing import Any

from pydantic import BaseModel, Field

logger = logging.getLogger(__name__)


class AnalysisStatus(str, Enum):
    """Status of a malware analysis."""

    PENDING = "pending"
    RUNNING = "running"
    COMPLETED = "completed"
    FAILED = "failed"


class ThreatLevel(str, Enum):
    """Threat level of a detected malware."""

    BENIGN = "benign"
    SUSPICIOUS = "suspicious"
    MALICIOUS = "malicious"
    CRITICAL = "critical"


class Detection(BaseModel):
    """A malware detection result."""

    name: str
    threat_level: ThreatLevel
    confidence: float = Field(..., ge=0, le=1.0)
    description: str
    indicators: list[dict[str, Any]] = []


class AnalysisResult(BaseModel):
    """Result of a malware analysis."""

    analysis_id: str
    filename: str
    file_hash: str
    file_size: int
    mime_type: str
    status: AnalysisStatus = AnalysisStatus.PENDING
    threat_level: ThreatLevel = ThreatLevel.BENIGN
    score: float = 0.0
    detections: list[Detection] = []
    metadata: dict[str, Any] = {}
    created_at: datetime = Field(default_factory=datetime.utcnow)
    updated_at: datetime = Field(default_factory=datetime.utcnow)


class MalwareAnalyzer:
    """Tool for analyzing files and processes for potential malware."""

    def __init__(self, config: dict[str, Any] | None = None):
        """Initialize the MalwareAnalyzer.

        Args:
            config: Configuration dictionary with optional keys:
                - quarantine_dir: Directory to store quarantined files
                - analysis_dir: Directory to store analysis results
                - max_file_size: Maximum file size to analyze in bytes
                - retention_days: Number of days to keep analysis results
        """
        config = config or {}
        self.quarantine_dir = Path(config.get("quarantine_dir", "./quarantine"))
        self.analysis_dir = Path(config.get("analysis_dir", "./analysis"))
        self.max_file_size = config.get("max_file_size", 100 * 1024 * 1024)  # 100MB
        self.retention_days = config.get("retention_days", 30)

        # Ensure directories exist
        self.quarantine_dir.mkdir(parents=True, exist_ok=True)
        self.analysis_dir.mkdir(parents=True, exist_ok=True)

        # In-memory storage for analysis results
        self.analyses: dict[str, AnalysisResult] = {}

        # Background tasks - will be initialized when needed
        self.cleanup_task = None
        self._initialized = False

    async def analyze_file(self, file_path: Path) -> str:
        """Analyze a file for malware.

        Args:
            file_path: Path to the file to analyze

        Returns:
            str: Analysis ID for tracking the analysis status
        """
        # Ensure we're initialized
        if not self._initialized:
            await self.initialize()
        """Analyze a file for malware.
        
        Args:
            file_path: Path to the file to analyze
            
        Returns:
            str: Analysis ID for tracking the analysis status
        """
        # Implementation here
        pass

    async def get_analysis(self, analysis_id: str) -> AnalysisResult:
        """Get the results of a malware analysis.

        Args:
            analysis_id: ID of the analysis to retrieve

        Returns:
            AnalysisResult: The analysis results

        Raises:
            ValueError: If no analysis with the given ID exists
        """
        if analysis_id not in self.analyses:
            raise ValueError(f"No analysis found with ID: {analysis_id}")
        return self.analyses[analysis_id]

    async def list_analyses(
        self,
        limit: int = 100,
        offset: int = 0,
        status: AnalysisStatus | None = None,
        threat_level: ThreatLevel | None = None,
    ) -> list[AnalysisResult]:
        """List all analyses with optional filtering.

        Args:
            limit: Maximum number of results to return
            offset: Number of results to skip
            status: Filter by analysis status
            threat_level: Filter by threat level

        Returns:
            List[AnalysisResult]: List of matching analysis results
        """
        results = list(self.analyses.values())

        # Apply filters
        if status:
            results = [r for r in results if r.status == status]
        if threat_level:
            results = [r for r in results if r.threat_level == threat_level]

        # Apply pagination
        return results[offset : offset + limit]

    async def delete_analysis(self, analysis_id: str) -> bool:
        """Delete an analysis and associated files.

        Args:
            analysis_id: ID of the analysis to delete

        Returns:
            bool: True if the analysis was deleted, False otherwise
        """
        if analysis_id not in self.analyses:
            return False

        # Delete analysis files
        analysis_dir = self.analysis_dir / analysis_id
        if analysis_dir.exists():
            shutil.rmtree(analysis_dir)

        # Delete from memory
        del self.analyses[analysis_id]
        return True

    async def list_quarantine(self) -> list[dict[str, Any]]:
        """List all files in quarantine.

        Returns:
            List[Dict[str, Any]]: List of quarantined files with metadata
        """
        quarantined = []
        for item in self.quarantine_dir.glob("*"):
            if item.is_file():
                quarantined.append(
                    {
                        "filename": item.name,
                        "size": item.stat().st_size,
                        "modified": datetime.fromtimestamp(item.stat().st_mtime),
                        "path": str(item),
                    }
                )
        return quarantined

    def _calculate_file_hash(self, file_path: Path) -> str:
        """Calculate the SHA-256 hash of a file.

        Args:
            file_path: Path to the file

        Returns:
            str: The SHA-256 hash of the file
        """
        sha256_hash = hashlib.sha256()
        with open(file_path, "rb") as f:
            # Read and update hash in chunks of 4K
            for byte_block in iter(lambda: f.read(4096), b""):
                sha256_hash.update(byte_block)
        return sha256_hash.hexdigest()

    def _get_file_type(self, file_path: Path) -> str:
        """Determine the file type using magic numbers.

        Args:
            file_path: Path to the file

        Returns:
            str: The detected file type
        """
        # This is a simplified implementation
        # In a real system, you'd use a library like python-magic
        ext = file_path.suffix.lower()
        if ext in [".exe", ".dll", ".sys"]:
            return "Windows Executable"
        elif ext in [".py", ".pyc", ".pyo"]:
            return "Python Script"
        elif ext in [".js", ".vbs", ".ps1", ".bat", ".cmd"]:
            return "Script"
        elif ext in [".doc", ".docx", ".xls", ".xlsx", ".ppt", ".pptx"]:
            return "Office Document"
        elif ext in [".pdf"]:
            return "PDF Document"
        else:
            return "Unknown"

    async def initialize(self) -> None:
        """Initialize async components and start background tasks."""
        if not self._initialized:
            self._start_cleanup_task()
            self._initialized = True

    def _start_cleanup_task(self) -> None:
        """Start the background task to clean up old analyses."""
        if self.cleanup_task is None or self.cleanup_task.done():
            try:
                self.cleanup_task = asyncio.create_task(self._cleanup_loop())
            except RuntimeError as e:
                if "no running event loop" in str(e):
                    # If there's no event loop, we'll start the task when one is available
                    logger.warning(
                        "No event loop available, cleanup task will start when one is available"
                    )
                else:
                    raise

    async def _cleanup_loop(self) -> None:
        """Background task to clean up old analyses."""
        while True:
            try:
                await self._cleanup_old_analyses()
            except Exception as e:
                logger.error(f"Error in cleanup task: {e}")

            # Run cleanup once per day
            await asyncio.sleep(24 * 60 * 60)

    async def _cleanup_old_analyses(self) -> None:
        """Clean up old analysis results and files."""
        cutoff = datetime.utcnow() - timedelta(days=self.retention_days)

        # Find old analyses
        to_delete = []
        for analysis_id, analysis in self.analyses.items():
            if analysis.updated_at < cutoff:
                to_delete.append(analysis_id)

        # Delete old analyses
        for analysis_id in to_delete:
            await self.delete_analysis(analysis_id)

        # Clean up old files in quarantine
        for item in self.quarantine_dir.glob("*"):
            if item.is_file() and item.stat().st_mtime < cutoff.timestamp():
                try:
                    item.unlink()
                except Exception as e:
                    logger.error(f"Failed to delete old file {item}: {e}")


# Lazy-loaded singleton instance
_malware_analyzer_instance = None


def get_malware_analyzer() -> "MalwareAnalyzer":
    """Get the singleton instance of MalwareAnalyzer.

    Returns:
        MalwareAnalyzer: The singleton instance
    """
    global _malware_analyzer_instance
    if _malware_analyzer_instance is None:
        _malware_analyzer_instance = MalwareAnalyzer()
    return _malware_analyzer_instance


# For backward compatibility
malware_analyzer = get_malware_analyzer()


# Export the tool functions with async initialization
async def analyze_file(file_path: Path) -> str:
    """Analyze a file for malware.

    Args:
        file_path: Path to the file to analyze

    Returns:
        str: Analysis ID for tracking the analysis status
    """
    analyzer = get_malware_analyzer()
    if not analyzer._initialized:
        await analyzer.initialize()
    return await analyzer.analyze_file(file_path)


async def get_analysis(analysis_id: str) -> AnalysisResult:
    """Get the results of a malware analysis."""
    analyzer = get_malware_analyzer()
    if not analyzer._initialized:
        await analyzer.initialize()
    return await analyzer.get_analysis(analysis_id)


async def list_analyses(
    limit: int = 100,
    offset: int = 0,
    status: AnalysisStatus | None = None,
    threat_level: ThreatLevel | None = None,
) -> list[AnalysisResult]:
    """List all analyses with optional filtering."""
    analyzer = get_malware_analyzer()
    if not analyzer._initialized:
        await analyzer.initialize()
    return await analyzer.list_analyses(limit, offset, status, threat_level)


async def delete_analysis(analysis_id: str) -> bool:
    """Delete an analysis and associated files."""
    analyzer = get_malware_analyzer()
    if not analyzer._initialized:
        await analyzer.initialize()
    return await analyzer.delete_analysis(analysis_id)


async def list_quarantine() -> list[dict[str, Any]]:
    """List all files in quarantine."""
    analyzer = get_malware_analyzer()
    if not analyzer._initialized:
        await analyzer.initialize()
    return await analyzer.list_quarantine()


# Export models
__all__ = [
    "AnalysisStatus",
    "ThreatLevel",
    "Detection",
    "AnalysisResult",
    "analyze_file",
    "get_analysis",
    "list_analyses",
    "delete_analysis",
    "list_quarantine",
]
